---
id: tracking-existing-components
title: Tracking Existing Components
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

You can onboard an existing set of components to be Bit components using the `bit add` command. If you would like to [create new components](/getting-started/compose-components/create-components) we suggest you use the `bit create` command.

During the onboarding process Bit marks directories to components. For each Bit Component, Bit does the following:

- Marks the component directory.
- Sets the component ID.
- Sets the component entry point.
- Parse and resolve dependency graph.
- Create a [Component Module Link](/workspace/component-link).

## Recommendations

- Start tracking components bottom-up, so all components that are shared by other components are tracked first.
- Plan and arrange components in namespaces according to their functionality, similar to the way you would arrange them in folders in a project.
- Run `bit show` to see each component applied configuration.
- Use `bit start` to view component.
- Refactor `import` statements to use Component Module Links generated by Bit.

## Initialize Bit Workspace

Use the `init` command to initialize a Bit Workspace

```sh
bit init
```

### Configure Workspace

Configure your `workspace.json` to fit your requirements. Read more [here](/workspace/workspace-json).

## Run the Dev Server

Run the Bit dev server to see onboarded components.

```sh
bit start
```

## Add Pre-existing Components

Each component in a Bit workspace must have all its implementation files under the same directory. A component must have an entry file, (`index.[ts|js]`) is used as the default. Angular components use `public-api.[ts|js]` as the entry file.

<Tabs
groupId="frameworks"
defaultValue="React"
values={[
{label: 'React', value: 'React'},
{label: 'Angular', value: 'Angular'},
]}>
<TabItem value="React">

```bash {4,5}
└── ui/my-component
    ├── index.tsx
    ├── my-component.tsx
    ├── my-component.docs.mdx
    ├── my-component.specs.tsx
    └── my-component.composition.tsx
```

  </TabItem>
  <TabItem value="Angular">

```bash
└── my-component
    ├── public-api.ts
    └── src
        ├── my-component.component.ts
        ├── my-component.module.ts
        ├── my-component.spec.ts
        ├── my-component.docs.md
        └── compositions
            └── my-component.composition.ts
```

  </TabItem>
</Tabs>

To add your component to the workspace run the `bit add` command followed by the namespace. The namespace is the the component folder structure you would like to see in your workspace.

Adding the namespace directly:

```bash
bit add ui/my-component
```

Using the namespace flag:

```bash
bit add my-component --namespace ui
```

Bit will map this component's files and register them in the `.bitmap` file. This enables Bit to treat a collection of files as a single unit, a component.

In addition to that, Bit will generate a component ID, with the pattern `<namespaces>/<component-name>`. The component ID will be prefixed with the scope name once it has been exported to a remote scope (`<owner>.<scope>/<namespaces>/<component-name>`).

<!--TODO Learn more about [adding components](/) and [removing components](/) -->

### Add multiple components at once?

To add multiple components, set the path to the common directory and use the `*` wildcard.

```bash
bit add path/to/common/dir/*
```

## Component Isolation Status

Bit helps you to isolate components. Run the `status` command to gain insights on how well isolated your components are.

```sh
bit status
```

## Rendering Components

To [render your component](/compositions/overview) - create a \*.compositions.tsx
To visualize components we use the `.compositions` file. Compositions allow us to create our components in different states. This also means we can test our components in different states. Compositions are the main dev tool for building with components. They provide a dedicated dev-server per each component where you can create fully featured apps with support for state management, theming and routing. Compositions act like consuming applications that compose and simulate components in various use cases.

Bit runs a dev server for components that shows all component compositions. Run the dev server and browse components to see their compositions.

```sh
bit start
```

### Video Guide

<iframe
  width="560"
  height="315"
  src="https://www.youtube.com/embed/so8CcUzTrn4?rel=0"
  title="How to Render your Component"
  frameborder="0"
  allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
  allowfullscreen
></iframe>

Add compositions to a component by creating a file in the component's directory, using the `*.compositions.*` pattern.

## Documenting Components

Documentation is a critical when building with components. Bit implements several features for component documentation to improve the dev experience and increase component adoption.

There are several ways to document components in Bit. Some of them are manual and some derived from your component-centric workflow. Bit features a dynamic documentation template for components that aggregates several sources and generates a single documentation page per component.

:::tip All components get documentation
Even if you haven't written any docs or used any feature, Bit still generates a basic documentation page for your component with basic installation instructions.
:::

### Video Guide

<iframe
  width="560"
  height="315"
  src="https://www.youtube.com/embed/cKMghSe_1RU?rel=0"
  title="How to add Docs to your Bit components"
  frameborder="0"
  allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
  allowfullscreen
></iframe>

To add [documentation](/docs/overview) to your component - create a \*.docs.md

## Testing Components

Tests become even more viable when working in a component based workflow. Components can be composed in many unique use cases, so having tests to check for them can reduce the amount of integration and experimentation needed in the future. Bit uses open source test runners to execute component tests.

### Video Guide

<iframe
  width="560"
  height="315"
  src="https://www.youtube.com/embed/R0LWV2gcbf8?rel=0"
  title="Testing your Components"
  frameborder="0"
  allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
  allowfullscreen
></iframe>

### Add Tests

Add [tests](tester/overview)to a component by creating a file in the component's directory, using the `*.spec/test.*` pattern.

:::info tests are great addition for documentation
A visual test result helps consumers to learn about the different edge cases supported by your component and makes it easy for them to want to adopt your code.
:::

## Use a different entry point

The default entry point for non Angular components is `index.ts`/`index.js`. To set a different entry point:

```bash
bit add <path to component> --main <entry file>
```

Set main.js as entry point:

```bash
bit add components/ui/my-component --main main.js
```
