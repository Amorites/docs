---
title: Micro Frontend
id: mfe
---

import depGraph from './graph.png';

Micro Frontends is a way for autonomous Frontend teams to collaborate on one or more web applications by composing them from independently versioned components.  
The idea is to break down the monolithic frontend application into smaller components, which can be developed and tested independently and composed into larger applications.

The benefit of using Bit for building an MFE workflow is that it is a native way for how modern web frameworks are designed. Bit allows an organization gains all the benefits of integrating between teams and components as part of an application build pipeline while still distribute development efforts across different teams and make any component reuseable.

[Dan Abramov tweet](https://twitter.com/dan_abramov/status/1132493678730252288?lang=en) // screenshot? embed tweet?

## Benefits

Using Bit for building Micro Frontends focuses on the developer experience for both MFE maintainers and application builders. Bit MFE workflow has unique attributes and characteristics.

### Autonomous Teams

Bit's MFE workflow focuses on having multiple teams building and collaborating on a large, overarching component model. Much like how a single team would build a component model for a single application in a single repository - in Bit all team's components are available for other teams to compose with regardless of where they were developed.

A single team could be responsible for implementing all components related to a specific business domain and publishing them for other teams to use. The team can manage components in a single, or several, repositories, depending on their needs.

### Developer Experience

Bit facilitates a bottom-up approach for systems engineering. Meaning team builds a set of components and then quickly ramp up and compose more concrete and specialized components with them; like widgets, forms, features, pages and even applications. This fits how modern web frameworks are focused on building modular systems from atomic components ([React Components](https://reactjs.org/docs/components-and-props.html), [Angular Modules](https://angular.io/guide/feature-modules) and [Vue components](https://vuejs.org/v2/guide/components.html)).  

Building with components or modules is at the core of modern web development. Teams building components and others adopting them is as native for the consumer as if they would use a component from their own codebase. When it's easy and native for a developer to integrate different components to build their component/feature/app, it makes the development process work more like **rapid application development** where a developer compose together self-contained pieces of functionality to a larger user-experience.

### Better Runtime Performance

Most MFE approaches rely on runtime consumption of deployed applications. If not being careful the end-user experience may result in a significant performance hit.  
By using Bit to build a single component model for an application the target build will have a single component model and bundle. This means the application itself can better manage it's performance with an optimized bundle for its requirement using code splitting, better de-duping of dependencies, a single application runtime which all results in a minimal JavaScript payload size.

### Consistent User Experience

We want to build progressive web applications that combine data from various sources, allow complex interactions and still keep consistent look and feel. Building this level of complexity and consistency requires high level of code reuse. This granular level of code reuse is a fundamental aspect of Bit and a key requirement for building consistent use experiences.  
Bit achieves consistent user experience by allowing reuse of components. These component can be a part of the organization design system, features that several apps need or even middleware and SDKs for integrating with other services. By opting for reuse rather then re-implement we also future proof our apps to remain consistent with future updates and changes.

### Deep Integration and Communication

Bit helps MFEs become a core part of the consumer's app. It allows for more complex and dynamic interactions. For example, when using this approach in Angular developers can compose modules together using the `@NgModule` decorator, meaning they can use advanced patterns like dependency injection and lazy loading. In React they can provide context to components and even utilize hooks to compose their components together with the rest of the application.

This deep integration enables building responsive application, as it allows us to better handle routing, history and deep-linking, even when MFEs were built by different teams.

### Stable and Safe Incremental Updates

Each MFE has its own semantic version and independent build-pipeline, this helps consumers in two important ways: first of all, they know which of the MFEs they use has a pending update and secondly the semantic version communicates the type of change applied the MFE has. All this flow happens during the app's build. It means consumers know how an MFE update may affect their app and handle it accordingly. When integrating during a build, we can be sure we don't introduce bugs to the app.

In a nutshell Bit allows developers to decide how and when they want to adopt any change, and when a change is dangerous for them, they can decide to adopt it gradually. On the other hand, MFE builders can move forward quickly without the constant fear of breaking their dependents. The result of it is a huge gain in the speed of delivery.

### Decouple Team Collaboration from Runtime Composition TODO

Often we see organizations opt to use runtime composition of frontend applications as a "do all" solution without considering the drawbacks it may have on performance, SEO and MFE composition. But we need to understand the teams requirements and needs to properly consider the tradeoffs. Defaulting to build-time composition lets teams focus and collaborate on building a coherent component model for their large scale application. This makes the discussion about runtime composition (with its different flavors) to be more pragmatic as we can decide to use it when needed.  

When runtime composition is needed, there are different methods where Bit can be used to answer some of the questions it raises. [See here.](/)

### Simple, decoupled codebase

Smaller codebases are easier to maintain as they simply have less code. When distributing a single component model across multiple teams and multiple repositories we make each repository to be as small as it can be. Moreover, as all other components are available to be dependencies it makes it even easier to ensure a single codebase contains a very focused set of components.

Bit also provides a dynamic way to scale decoupled codebases, especially in cases where a codebase grows and needed to be split to several others. Bit can "source" a component to any codebase including its complete version history. So when a codebase grows too large we can split it to several smaller codebases without loosing history and context. Developers can use this capability to quickly spin up new codebases for specific requirements and use them for different experimentations POCs.

### Standardization

Ramping up the production of MFEs requires solving many small problems many times. For example, how an MFE should be constructed, testing and code quality are some of the basic requirements each developer needs to think about when building new MFE.  
Bit helps make this process repeatable and scale-able with using **environments**. This way an organization keep different types of standards according to the specific type of MFE making the process of creating new features and APIs repeatable and quick.

## In Practice

Bit allows to distributed a single a large scale component model of a frontend to many teams. The following example shows an e-commerce organization building several apps. Each team is responsible on a different cross-cutting concern while consuming and components built by other teams.

// TODO IMAGE

### Git Repositories

A Bit workspace is a monorepo for components. A teams can use a single Git repository to manage the lifecycle of many components from a single place. This can simplify the flow of managing closely-related components that may have the same dependencies, or need to depend on each other.  
While components share the same workspace, they each get its own build pipeline and independent versions without overwhelming your workspace with many configuration files. This has several benefits:

1. Only changed components and their dependents get a new version.
1. Components from the same workspace may be built with different tools and frameworks.
1. Focus on the implementation and less on managing configurations and dependencies.

The structure of components on the filesystem is non-opinionated, meaning you can have components nested in complex directory hierarchy or have them flatten, however it fits your use case. Moreover, you can move components around in the workspace without it affecting their functionality, allowing for better flexibility when amount of components grow and you want to reorder the workspace.

Bit makes the team's workspace dynamic and flexible to their needs, enabling teams to scale to more components without locking them down to past decisions regarding workspace structure.

// TODO IMAGE + 

### Build-time Composition

To achieve build time compositions all shared components and MFEs are consumable as packages for different applications and even other components. With a simple `npm install` command any developer can compose any ready-made components to their application and embed a new feature to their application.

// TODO diagram + example

### Run-time Composition

Runtime composed frontends is about using different strategies to load code that is not a part of the application when a user access a page or feature. This makes critical parts of the end-user journey within a single application to be loosely coupled. This approach has several drawbacks:

- No de-duping of shared code and dependencies as this is a bundle feature which runs during a build pipeline.
- Complex communication between the application and composed MFEs is often moved to a message bus or eventing system that is hard to scale when the number of MFE grows.
- Application maintainers get less control over their production runtime, as skipping application-MFE integration tests my result in MFE-teams delivering potentially breaking changes or bugs directly to the consumer's runtime.
- Runtime metrics, KPIs, logs and reports for applications with runtime MFEs are harder to achieve, as they are distributed between it and the various MFEs composed.

There are cases where its reasonable to utilize this approach. This can be useful as a deployment strategy where we know APIs will not change often or for integrating with legacy systems.

#### SDK Library

A way to mitigate some of the issues around runtime compositions is building an SDK for each MFE. An SDK is a library that wraps a runtime integrated MFE in a way the consumer can use it as if it was a dependency. Regardless of how the runtime MFE is deployed, an SDK can provide several benefits:

- Decouple the MFE deployment strategy from how it is integrated.
- Provide programmatic APIs simplify dev-experience with auto-complete, types (with TypeScript), functions and other APIs.
- Abstract complex situations and error handling by the MFE publisher.
- Provide framework-specific APIs for consumers to simplify and reduce integration time for consumers
- Less documentation needed to integrate MFE.

// TODO diagram + example

#### Module Federation

[Module Federation](https://webpack.js.org/concepts/module-federation) is a new plugin introduced with Webpack 5 release. According to the Webpack documentation it is "Multiple separate builds should form a single application. These separate builds should not have dependencies between each other, so they can be developed and deployed individually". With this in mind many teams have began using this new tool as a way to create runtime composition for their frontend.

MF is a game changer in regards to runtime composition, it allows the browser to have runtime-composed MFEs share a single application-runtime and even shared dependencies. However, it still suffers from some issues we see hurting teams that chose this approach to scale when implemented in large organizations. The main issue is 

- Only supports Webpack 5, so teams using other bundlers can't use shared MFEs.
- No shared types and IDE auto-complete when teams opt for separating repositories.
- `peerDependencies` need to be in-sync.



:::info

Native Webpack 5 Module Federation support is in development. [See here](https://github.com/teambit/bit/discussions/4640) for more details.

:::

#### Bundle from CDN

third party JS

#### ES Modules in the browser

Future of runtime frontend composition is ES Modules. This means that we can use ES modules in the browser and use them in the Node.js runtime.

### Multiple Frameworks

- possible
  - buildtime
  - runtime
- do it only if really needed
- how

### Data Fetching

- api gateway
- BFF pattern

### Modeling data entities

- more than shared types
- mock data

### Updates

- npm i
- build
- ripple ci



### Feature Ownership

- hi

### Styling and Theming

- encapsulation

### Testing

Each component is testing itself and its dependencies.

### Applications D& Deployment

- apps are just very concrete components

## Summary

- yup

### Decouple application runtime from collaboration model

- make the right decisions

### The Microservice Analogy

While sharing a similar name and benefiting from splitting system engineering and teams according to business capabilities, Microservices and Micro Frontends architectures are very different.  
Micro Frontends still run by the browser as a monolithic application with a shared runtime while Microservices are deployed to different servers and communicate over the network.

Modern web frameworks already solve the problem of building modular applications from independent and decoupled services to scale frontend development (React/Vue component, Angular modules). The pragmatic approach for scaling delivery of large scale applications is adopting their approach but finding a way to distributed the development of an application across teams and repositories. This requires a different set of tools and thinking than scaling backend development.

### Not just for frontend

?
