---
title: Micro Frontend
id: mfe
---

import depGraph from './graph.png';

Micro Frontends is a way for autonomous Frontend teams to collaborate on one or more web applications. Bit helps distributed teams collaborate on building a component model where components are versioned and release separately so they can be orchestrated to form features, pages and applications.

This fits how modern web frameworks are designed to build and maintain modular systems ([React Components](https://reactjs.org/docs/components-and-props.html), [Angular Modules](https://angular.io/guide/feature-modules) and [Vue components](https://vuejs.org/v2/guide/components.html)). It facilitates a bottom-up approach for systems engineering, meaning teams can build a set of components and then quickly ramp up and compose more concrete and specialized components with them; like widgets, forms, features, pages and even applications.

In a nutshell it makes systems building more modular and the development of apps native to modern web frameworks.

[Dan Abramov tweet](https://twitter.com/dan_abramov/status/1132493678730252288?lang=en) // screenshot? embed tweet?

## Benefits

The main benefit of using Bit for building an MFE workflow is that it is a native way for how modern web frameworks are designed. This means an organization gains all the benefits of integrating between teams and components as part of an application build pipeline while still being able to distribute development efforts across different teams and make any component reuseable.

### Control Application Performance

Most MFE approaches rely on runtime consumption of deployed applications. If not being careful the end-user experience may result in a significant performance hit.

By using Bit to build a single component model and consuming most components in build time, the result application will have a single component model and bundle. This means the application itself can better manage it's performance:

- Optimized bundle.
- Code splitting.
- Better de-duping of dependencies.
- Single application runtime.
- Minimal JavaScript payload size.

Runtime dependencies can still be used (see below), however with Bit teams can make more informed decisions for when to use this pattern. This is because Bit decouples the organization structure of how teams collaborate from how an application is deployed.

### Consistent User Experience

The main concern when using any MFE approach is how to deliver a consistent user experience. A consistent user experience is built on top of two main items

**Atomic components** usually refers to a "design system", a set of base components we use to compose our UI. These components have to be consistent across all MFEs. We can include the set of base UI components into our component model for all teams to compose with, thus building a consistent UI.  
Another interesting usage for a component model is "componentizing" more than just the base UI components in the component model. We can include data-fetching, SDKs, and other components, streamlining more parts of the user-experience.

**Application state** is a fundamental part of the user experience. Building with a component model means all components communicate natively, making the user experience more responsive and easy to build. When introducing runtime dependencies we force the application to sync MFEs and ensure they can communicate. This adds a lot of complexity and is hard to scale when more MFEs are introduced, eventually hurting the flow of the product.

### Stable, Safe and Incremental Updates

Teams invest time in making sure their application is tested and validated before shipped to our end-users. When integrating components and building modular apps teams get to run their build pipeline to validate their dependencies does not break them. This way they ensure the stability of their application.

Each change to a component propagates in the component model to all components interacting with it, making each change testable from the consumer's perspective. This makes it easier to know which change caused a performance decrease or introduced unwanted behaviors.

### Improve Developer Experience

Building with components or modules is at the core of modern web development. Having autonomous teams building components and having consumers adopting them is as native for the consumer as if they would use a component from their own codebase. This improves the delivery of new capabilities by making the component integration using native framework features instead of using complex messaging or eventing systems for integrations.

When it's easy for a developer to integrate different components to build their module feature/app, it makes the development process work more like **rapid application development** where a developer pieces together self-contained pieces of functionality to compose a larger user-experience.

### Simple, decoupled codebase

Smaller codebases are easier for developers to maintain as they simply have less code. When distributing a single component model across multiple teams and multiple repositories we get this exact benefit. It results with increase in developer productivity.  
The rest of the components are available to be installed as dependencies, making it even easier to build more complex features and compose more concrete components.

Codebase can also become more dynamic when wanting to scale a team. Bit can "source" a component to any codebase including its complete version history. This means that when a codebase grows too large we can split it to several smaller codebases without loosing any of the past versions. Developers can use this capability to quickly spin up new codebases for specific requirements and use them for different experimentations POCs.

### Autonomous Teams

Teams build independently versioned components, where each component has its own dependency graph. This means that cross team collaboration and integration is done primarily using dependencies. Developers to decide how and when they want to adopt any change, and when a change is dangerous for them, they can decide to adopt it gradually.

By managing versioning in the component model teams can move forward quickly without the constant fear of breaking their dependents. The result of it is a huge gain in the speed of delivery.

### Code Reuse

With bottom-up approach for systems engineering, where individual components consumed as dependencies teams get instant ability to reuse all previously implemented components and use them to compose more complex functionality. The organization gains the benefits of working in a single monolith, where all code is available to consume as a dependency but still keep each codebase small and focused on a single cross cutting concern.

The end result with such degree and granularity of code reuse is gaining an almost Rapid Application Development type of workflow for developers.

### Standardization

Ramping up the production of components requires solving many small problems many times. For example, how a component should be constructed, testing components, keeping code quality are some of the basic requirements each developer needs to think about when building new components. When working with components its also important to provide global context for components like theme, API gateway, globalization and others.  
Bit helps make this process repeatable and scale-able with using **environments**. This way an organization keep different types of standards according to the specific type of component making the process of creating new features and APIs repeatable and quick.

Organizations can build a set of environments with dependencies between them for cases where a team may need to extend of further customize their components.

## In Practice

Bit allows to distributed a single a large scale component model of a frontend to many teams. The following example shows an e-commerce organization building several apps. Each team is responsible on a different cross-cutting concern while consuming and components built by other teams.

// TODO IMAGE

### Git Repositories

A Bit workspace is a monorepo for components. A teams can use a single Git repository to manage the lifecycle of many components from a single place. This can simplify the flow of managing closely-related components that may have the same dependencies, or need to depend on each other.  
While components share the same workspace, they each get its own build pipeline and independent versions without overwhelming your workspace with many configuration files. This has several benefits:

1. Only changed components and their dependents get a new version.
1. Components from the same workspace may be built with different tools and frameworks.
1. Focus on the implementation and less on managing configurations and dependencies.

The structure of components on the filesystem is non-opinionated, meaning you can have components nested in complex directory hierarchy or have them flatten, however it fits your use case. Moreover, you can move components around in the workspace without it affecting their functionality, allowing for better flexibility when amount of components grow and you want to reorder the workspace.

Bit makes the team's workspace dynamic and flexible to their needs, enabling teams to scale to more components without locking them down to past decisions regarding workspace structure.

### Build-time Composition

To achieve build time compositions all shared components and MFEs are consumable as packages for different applications and even other components. With a simple `npm install` command any developer can compose any ready-made components to their application and embed a new feature to their application.

With build time integration the MFE introduced becomes a core part of the consumer's component model, making it easier and more efficient to work with and share the same runtime. It allows for more complex and dynamic interactions. For example, when using this approach in Angular developers can compose modules together using the `@NgModule` decorator, meaning they can use advanced patterns like dependency injection and lazy loading. In React they can provide context to components and even utilize hooks to compose their components together with the rest of the application.

// TODO diagram + example

### Run-time Composition

- possible
- when we should do it (deployment startegy)
- build SDK for it
- loading 3rd party code from CDN / remote server
- serverside includes
- module federation
- es modules

### Data Fetching

- api gateway
- BFF pattern

### Modeling data entities

- more than shared types
- mock data

### Updates

- npm i
- build
- ripple ci

### Multiple Frameworks (Runtimes)

- possible
- do it only if really needed
- how

### Feature Ownership

- hi

### Styling and Theming

- encapsulation

### Testing

Each component is testing itself and its dependencies.

### Applications D& Deployment

- apps are just very concrete components

## Summary

- yup

### Decouple application runtime from collaboration model

- make the right decisions

### The Microservice Analogy

While sharing a similar name and benefiting from splitting systems and teams according to business capabilities, Microservices and Micro Frontends are very different.  
Micro Frontends run on the browser and share the same runtime. This means that unlike Microservices, teams has different costs on tech stack independence.

However, sharing the same runtime means we can build better and faster inner-communication between MFEs, as we don't need to "pay" the premium of network requests between Microservices. Moreover, MFEs has the possible benefit of using programmatic APIs to improve dev-experience and improve integration workflow between teams.

### Not just for frontend

?
