---
title: Micro Frontend
id: mfe
---

import depGraph from './graph.png';

Micro Frontends is a way for autonomous Frontend teams to collaborate on one or more web applications. Teams can break down the Frontend monolith to smaller pieces (components/modules) which are then composed to building larger applications.

While web applications are modular they are normally built in a monolithic codebase. This approach make it hard to scale frontend development in large organizations as it is hard for many developers to build in a single codebase. With Bit you can distribute your frontend development across multiple teams and codebases. A team will still own, build and take responsibility on a different cross-cutting business concern, and these will be then integrated together to form apps and user-experiences.

This is Bit's approach for implementing Micro Frontends. It fits with how modern web frameworks are designed to maintain modular systems ([React Components](https://reactjs.org/docs/components-and-props.html), [Angular Modules](https://angular.io/guide/feature-modules) and [Vue components](https://vuejs.org/v2/guide/components.html)) and how the browser treats JavaScript applications. This bottom-up approach for systems engineering means teams can build a set of atomic components and then quickly ramp up and compose more concrete and specialized components like widgets, forms, features, pages and even applications. With this in mind, the ability to collaboratively build a component model can help organizations deliver faster.

In a nutshell it makes systems building more modular, the development of apps native to modern web frameworks and more importantly decouples application runtime from team collaboration.

[Dan Abramov tweet](https://twitter.com/dan_abramov/status/1132493678730252288?lang=en) // screenshot? embed tweet?

:::tip The Microservice Analogy

While sharing a similar name and benefiting from splitting systems and teams according to business capabilities, Microservices and Micro Frontends are very different.  
Micro Frontends run on the browser and share the same runtime. This means that unlike Microservices, teams has different costs on tech stack independence.

However, sharing the same runtime means we can build better and faster inner-communication between MFEs, as we don't need to "pay" the premium of network requests between Microservices. Moreover, MFEs has the possible benefit of using programmatic APIs to improve dev-experience and improve integration workflow between teams.

:::

## Benefits

Our goal is to put the end-user experience at the top and see what is the optimal way to get to it. This means the reasons teams should consider adopting and MFE workflow should derived by how they can improve their application. However, when adopting this workflow with Bit there are some inherit organizational benefits.

### Control Application Performance

Most MFE approaches rely on runtime consumption of deployed applications. This means they couple team collaboration with how application operating in runtime. The result of this coupling is that if not being careful the end-user experience may result in a significant performance hit.

By using Bit to share and build a single component model, and consuming most components in build time, developers build a single component model for each application. As this happens during build time the application's runtime is decoupled from how team collaboration is managed.  
This means the application itself can better manage it's performance:

- Optimized bundle.
- Code splitting.
- Better de-duping of dependencies.
- Single application runtime.
- Minimal JavaScript payload size.

With this approach teams can make more informed decisions for when to use runtime dependencies for when they are needed most, like shorten deployment time for certain parts of our technology or embedding legacy/third-party code.

### Consistent User Experience

The main concern when using any MFE approach is how to deliver a consistent user experience. A consistent user experience is built on top of two main items

**Atomic components** usually refers to a "design system", a set of base components we use to compose our UI. These components have to be consistent across all MFEs. We can include the set of base UI components into our component model for all teams to compose with, thus building a consistent UI.  
Another interesting usage for a component model is "componentizing" more than just the base UI components in the component model. We can include data-fetching, SDKs, and other components, streamlining more parts of the user-experience.

**Application state** is a fundamental part of the user experience. Building with a component model means all components communicate natively, making the user experience more responsive and easy to build. When introducing runtime dependencies we force the application to sync MFEs and ensure they can communicate. This adds a lot of complexity and is hard to scale when more MFEs are introduced, eventually hurting the flow of the product.

### Stable, Safe and Incremental Updates

Teams invest time in making sure their application is tested and validated before shipped to our end-users. When integrating components and building modular apps teams get to run their build pipeline to validate their dependencies does not break them. This way they ensure the stability of their application.

Each change to a component propagates in the component model to all components interacting with it, making each change testable from the consumer's perspective. This makes it easier to know which change caused a performance decrease or introduced unwanted behaviors.

### Improve Developer Experience

Building with components or modules is at the core of modern web development. Having autonomous teams building components and having consumers adopting them is as native for the consumer as if they would use a component from their own codebase. This improves the delivery of new capabilities by making the component integration using native framework features instead of using complex messaging or eventing systems for integrations.

When it's easy for a developer to integrate different components to build their module feature/app, it makes the development process work more like **rapid application development** where a developer pieces together self-contained pieces of functionality to compose a larger user-experience.

### Simple, decoupled codebase

Smaller codebases are easier for developers to maintain as they simply have less code. When distributing a single component model across multiple teams and multiple repositories we get this exact benefit. It results with increase in developer productivity.  
The rest of the components are available to be installed as dependencies, making it even easier to build more complex features and compose more concrete components.

Codebase can also become more dynamic when wanting to scale a team. Bit can "source" a component to any codebase including its complete version history. This means that when a codebase grows too large we can split it to several smaller codebases without loosing any of the past versions. Developers can use this capability to quickly spin up new codebases for specific requirements and use them for different experimentations POCs.

### Autonomous Teams

- Any one can change and modify any code.
- Pin to older versions of components.
- Never break, never be break.

### Code Reuse

- core capability
- component reuse

### Standardization

- Standardizing on frameworks.
- Standardization of code quality (testing, linting, security, etc.).
- Easy and repeatable experience for creating components, MFEs, etc.
- Standardizing the process of creating new features and APIs.

## In Practice

Bit allows to distirbuted a single a large scale component model of a frontend to many teams. The following example shows an ecommerence organization building several apps. Each team is responsible on a different cross-cutting concern while consuming and components built by other teams.

// TODO IMAGE

### Git Repositories

- collaboration
- shared workspace

### Build-time Composition

- todo

### Run-time Composition

- possible
- when we should do it (deployment startegy)
- build SDK for it
- third party js from a cdn
- html from a server
- serverside includes
- module federation
- es modules

### Data Fetching

- api gateway
- BFF pattern

### Modeling data entities

- more than shared types
- mock data

### Updates

- npm i
- build
- ripple ci

### Multiple Frameworks

- possible
- do it only if really needed
- how

### Feature Ownership

- hi

### Styling and Theming

- encapsulation

### Testing

Each component is testing itself and its dependencies.

### Applications D& Deployment

- apps are just very concrete components

## Summary

- yup

### Not just for frontend

?
