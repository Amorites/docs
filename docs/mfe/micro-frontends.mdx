---
title: Micro Frontend
id: mfe
---

import depGraph from './graph.png';

Micro Frontends is a way for autonomous Frontend teams to collaborate on one or more web applications by integrating composing wep applications from independently versioned components. A single team could be responsible for implementing cross-cutting business concerns and publishing features as components, while depending on other teams components if needed. The idea is to break down the monolithic frontend application into smaller components, which can be developed and tested independently and composed into larger applications.

Bit facilitates a bottom-up approach for systems engineering, meaning teams can build a set of components and then quickly ramp up and compose more concrete and specialized components with them; like widgets, forms, features, pages and even applications.  
This fits how modern web frameworks are focused on building modular systems from atomic and functional components ([React Components](https://reactjs.org/docs/components-and-props.html), [Angular Modules](https://angular.io/guide/feature-modules) and [Vue components](https://vuejs.org/v2/guide/components.html)) while also decouple the frontend runtime from how its codebase is managed.

[Dan Abramov tweet](https://twitter.com/dan_abramov/status/1132493678730252288?lang=en) // screenshot? embed tweet?

## Benefits

The main benefit of using Bit for building an MFE workflow is that it is a native way for how modern web frameworks are designed. This means an organization gains all the benefits of integrating between teams and components as part of an application build pipeline while still being able to distribute development efforts across different teams and make any component reuseable.

### Control Application Performance

Most MFE approaches rely on runtime consumption of deployed applications. If not being careful the end-user experience may result in a significant performance hit.

By using Bit to build a single component model and consuming most components in build time, the result application will have a single component model and bundle. This means the application itself can better manage it's performance:

- Optimized bundle.
- Code splitting.
- Better de-duping of dependencies.
- Single application runtime.
- Minimal JavaScript payload size.

Runtime dependencies can still be used (see below), however with Bit teams can make more informed decisions for when to use this pattern. This is because Bit decouples the organization structure of how teams collaborate from how an application is deployed.

### Consistent User Experience

The main concern when using any MFE approach is how to deliver a consistent user experience. A consistent user experience is built on top of two main items

**Atomic components** usually refers to a "design system", a set of base components we use to compose our UI. These components have to be consistent across all MFEs. We can include the set of base UI components into our component model for all teams to compose with, thus building a consistent UI.  
Another interesting usage for a component model is "componentizing" more than just the base UI components in the component model. We can include data-fetching, SDKs, and other components, streamlining more parts of the user-experience.

**Application state** is a fundamental part of the user experience. Building with a component model means all components communicate natively, making the user experience more responsive and easy to build. When introducing runtime dependencies we force the application to sync MFEs and ensure they can communicate. This adds a lot of complexity and is hard to scale when more MFEs are introduced, eventually hurting the flow of the product.

### Stable, Safe and Incremental Updates

Teams invest time in making sure their application is tested and validated before shipped to our end-users. When integrating components and building modular apps teams get to run their build pipeline to validate their dependencies does not break them. This way they ensure the stability of their application.

Each change to a component propagates in the component model to all components interacting with it, making each change testable from the consumer's perspective. This makes it easier to know which change caused a performance decrease or introduced unwanted behaviors.

### Improve Developer Experience

Building with components or modules is at the core of modern web development. Having autonomous teams building components and having consumers adopting them is as native for the consumer as if they would use a component from their own codebase. This improves the delivery of new capabilities by making the component integration using native framework features instead of using complex messaging or eventing systems for integrations.

When it's easy for a developer to integrate different components to build their module feature/app, it makes the development process work more like **rapid application development** where a developer pieces together self-contained pieces of functionality to compose a larger user-experience.

### Simple, decoupled codebase

Smaller codebases are easier for developers to maintain as they simply have less code. When distributing a single component model across multiple teams and multiple repositories we get this exact benefit. It results with increase in developer productivity.  
The rest of the components are available to be installed as dependencies, making it even easier to build more complex features and compose more concrete components.

Codebase can also become more dynamic when wanting to scale a team. Bit can "source" a component to any codebase including its complete version history. This means that when a codebase grows too large we can split it to several smaller codebases without loosing any of the past versions. Developers can use this capability to quickly spin up new codebases for specific requirements and use them for different experimentations POCs.

### Autonomous Teams

Teams build independently versioned components, where each component has its own dependency graph. This means that cross team collaboration and integration is done primarily using dependencies. Developers to decide how and when they want to adopt any change, and when a change is dangerous for them, they can decide to adopt it gradually.

By managing versioning in the component model teams can move forward quickly without the constant fear of breaking their dependents. The result of it is a huge gain in the speed of delivery.

### Code Reuse

With bottom-up approach for systems engineering, where individual components consumed as dependencies teams get instant ability to reuse all previously implemented components and use them to compose more complex functionality. The organization gains the benefits of working in a single monolith, where all code is available to consume as a dependency but still keep each codebase small and focused on a single cross cutting concern.

The end result with such degree and granularity of code reuse is gaining an almost Rapid Application Development type of workflow for developers.

### Standardization

Ramping up the production of components requires solving many small problems many times. For example, how a component should be constructed, testing components, keeping code quality are some of the basic requirements each developer needs to think about when building new components. When working with components its also important to provide global context for components like theme, API gateway, globalization and others.  
Bit helps make this process repeatable and scale-able with using **environments**. This way an organization keep different types of standards according to the specific type of component making the process of creating new features and APIs repeatable and quick.

Organizations can build a set of environments with dependencies between them for cases where a team may need to extend of further customize their components.

## In Practice

Bit allows to distributed a single a large scale component model of a frontend to many teams. The following example shows an e-commerce organization building several apps. Each team is responsible on a different cross-cutting concern while consuming and components built by other teams.

// TODO IMAGE

### Git Repositories

A Bit workspace is a monorepo for components. A teams can use a single Git repository to manage the lifecycle of many components from a single place. This can simplify the flow of managing closely-related components that may have the same dependencies, or need to depend on each other.  
While components share the same workspace, they each get its own build pipeline and independent versions without overwhelming your workspace with many configuration files. This has several benefits:

1. Only changed components and their dependents get a new version.
1. Components from the same workspace may be built with different tools and frameworks.
1. Focus on the implementation and less on managing configurations and dependencies.

The structure of components on the filesystem is non-opinionated, meaning you can have components nested in complex directory hierarchy or have them flatten, however it fits your use case. Moreover, you can move components around in the workspace without it affecting their functionality, allowing for better flexibility when amount of components grow and you want to reorder the workspace.

Bit makes the team's workspace dynamic and flexible to their needs, enabling teams to scale to more components without locking them down to past decisions regarding workspace structure.

### Build-time Composition

To achieve build time compositions all shared components and MFEs are consumable as packages for different applications and even other components. With a simple `npm install` command any developer can compose any ready-made components to their application and embed a new feature to their application.

With build time composition the MFE becomes a core part of the consumer's component model and build pipeline. It allows for more complex and dynamic interactions. For example, when using this approach in Angular developers can compose modules together using the `@NgModule` decorator, meaning they can use advanced patterns like dependency injection and lazy loading. In React they can provide context to components and even utilize hooks to compose their components together with the rest of the application.

// TODO diagram + example

### Run-time Composition

Runtime composed frontends is about using different strategies to load code that is not a part of the application when a user access a page or feature. This makes critical parts of the end-user journey within a single application to be loosely coupled. This approach has several drawbacks:

- No de-duping of shared code and dependencies as this is a bundle feature which runs during a build pipeline.
- Complex communication between the application and composed MFEs is often moved to a message bus or eventing system that is hard to scale when the number of MFE grows.
- Application maintainers get less control over their production runtime, as skipping application-MFE integration tests my result in MFE-teams delivering potentially breaking changes or bugs directly to the consumer's runtime.
- Runtime metrics, KPIs, logs and reports for applications with runtime MFEs are harder to achieve, as they are distributed between it and the various MFEs composed.
- Integrating MFEs can be complicated and required more work to get routing, history and deep-linking more complex, making it a challenge to build responsive applications.

There are cases where its reasonable to utilize this approach. This can be useful as a deployment strategy where we know APIs will not change often or for integrating with legacy systems.

#### SDK Library

A way to mitigate some of the issues around runtime compositions is building an SDK for each MFE. An SDK is a library that wraps a runtime integrated MFE in a way the consumer can use it as if it was a dependency. Regardless of how the runtime MFE is deployed, an SDK can provide several benefits:

- Decouple the MFE deployment strategy from how it is integrated.
- Provide programmatic APIs simplify dev-experience with auto-complete, types (with TypeScript), functions and other APIs.
- Abstract complex situations and error handling by the MFE publisher.
- Provide framework-specific APIs for consumers to simplify and reduce integration time for consumers
- Less documentation needed to integrate MFE.

// TODO diagram + example

#### Module Federation

[Module Federation](https://webpack.js.org/concepts/module-federation) is a new plugin introduced with Webpack 5 release. According to the Webpack documentation it is "Multiple separate builds should form a single application. These separate builds should not have dependencies between each other, so they can be developed and deployed individually". With this in mind many teams have began using this new tool as a way to create runtime composition for their frontend.

MF is a game changer in regards to runtime composition, it allows the browser to have runtime-composed MFEs share a single application-runtime and even shared dependencies. However, it still suffers from some issues we see hurting teams that chose this approach to scale when implemented in large organizations. The main issue is 

- Only supports Webpack 5, so teams using other bundlers can't use shared MFEs.
- No shared types and IDE auto-complete when teams opt for separating repositories.
- `peerDependencies` need to be in-sync.



:::info

Native Webpack 5 Module Federation support is in development. [See here](https://github.com/teambit/bit/discussions/4640) for more details.

:::

#### Bundle from CDN

third party JS

#### ES Modules in the browser

Future of runtime frontend composition is ES Modules. This means that we can use ES modules in the browser and use them in the Node.js runtime.

### Multiple Frameworks

- possible
  - buildtime
  - runtime
- do it only if really needed
- how

### Data Fetching

- api gateway
- BFF pattern

### Modeling data entities

- more than shared types
- mock data

### Updates

- npm i
- build
- ripple ci



### Feature Ownership

- hi

### Styling and Theming

- encapsulation

### Testing

Each component is testing itself and its dependencies.

### Applications D& Deployment

- apps are just very concrete components

## Summary

- yup

### Decouple application runtime from collaboration model

- make the right decisions

### The Microservice Analogy

While sharing a similar name and benefiting from splitting system engineering and teams according to business capabilities, Microservices and Micro Frontends architectures are very different.  
Micro Frontends still run by the browser as a monolithic application with a shared runtime while Microservices are deployed to different servers and communicate over the network.

Modern web frameworks already solve the problem of building modular applications from independent and decoupled services to scale frontend development (React/Vue component, Angular modules). The pragmatic approach for scaling delivery of large scale applications is adopting their approach but finding a way to distributed the development of an application across teams and repositories. This requires a different set of tools and thinking than scaling backend development.

### Not just for frontend

?
