---
title: Micro Frontend
id: mfe
---

import depGraph from './graph.png';

Micro Frontends is a way for autonomous Frontend teams to collaborate on one or more web applications by composing them from independently versioned components.  
The idea is to break down the monolithic frontend application into smaller components, which can be developed and tested independently and composed into larger applications.

The benefit of using Bit for building an MFE workflow is that it is a native way for how modern web frameworks are designed. Bit allows an organization gains all the benefits of integrating between teams and components as part of an application build pipeline while still distribute development efforts across different teams and make any component reuseable.

[Dan Abramov tweet](https://twitter.com/dan_abramov/status/1132493678730252288?lang=en) // screenshot? embed tweet?

## Benefits

Bit implements a build time approach for Micro Frontends allowing as a pragmatic approach for scaling frontend development across multiple teams. It is the middle-ground between two extremes - monolithic repository and loading JS code at runtime.

In short it allows you to reuse all components you have, gain benefits of build-time optimizations and decide when and where to pay the cost of runtime composition.

### Autonomous Teams

Bit's MFE workflow focuses on having multiple teams building and collaborating on a large, overarching component model. Much like how a single team would build a component model for a single application in a single repository - in Bit all team's components are available for other teams to compose with regardless of where they were developed.

A single team could be responsible for implementing all components related to a specific business domain and publishing them for other teams to use. The team can manage components in a single, or several, repositories, depending on their needs.

### Developer Experience

Bit facilitates a bottom-up approach for systems engineering. Meaning team builds a set of components and then quickly ramp up and compose more concrete and specialized components with them; like widgets, forms, features, pages and even applications. This fits how modern web frameworks are focused on building modular systems from atomic components ([React Components](https://reactjs.org/docs/components-and-props.html), [Angular Modules](https://angular.io/guide/feature-modules) and [Vue components](https://vuejs.org/v2/guide/components.html)).  

Building with components or modules is at the core of modern web development. Teams building components and others adopting them is as native for the consumer as if they would use a component from their own codebase. When it's easy and native for a developer to integrate different components to build their component/feature/app, it makes the development process work more like **rapid application development** where a developer compose together self-contained pieces of functionality to a larger user-experience.

### Better Runtime Performance

Most MFE approaches rely on runtime consumption of deployed applications. If not being careful the end-user experience may result in a significant performance hit.  
By using Bit to build a single component model for an application the target build will have a single component model and bundle. This means the application itself can better manage it's performance with an optimized bundle for its requirement using code splitting, better de-duping of dependencies, a single application runtime which all results in a minimal JavaScript payload size.

### Consistent User Experience

We want to build progressive web applications that combine data from various sources, allow complex interactions and still keep consistent look and feel. Building this level of complexity and consistency requires high level of code reuse. This granular level of code reuse is a fundamental aspect of Bit and a key requirement for building consistent use experiences.  
Bit achieves consistent user experience by allowing reuse of components. These component can be a part of the organization design system, features that several apps need or even middleware and SDKs for integrating with other services. By opting for reuse rather then re-implement we also future proof our apps to remain consistent with future updates and changes.

### Deep Integration and Communication

Bit helps MFEs become a core part of the consumer's app. It allows for more complex and dynamic interactions. For example, when using this approach in Angular developers can compose modules together using the `@NgModule` decorator, meaning they can use advanced patterns like dependency injection and lazy loading. In React they can provide context to components and even utilize hooks to compose their components together with the rest of the application.

This deep integration enables building responsive application, as it allows us to better handle routing, history and deep-linking, even when MFEs were built by different teams.

### Stable and Safe Incremental Updates

Each MFE has its own semantic version and independent build-pipeline, this helps consumers in two important ways: first of all, they know which of the MFEs they use has a pending update and secondly the semantic version communicates the type of change applied the MFE has. All this flow happens during the app's build. It means consumers know how an MFE update may affect their app and handle it accordingly. When integrating during a build, we can be sure we don't introduce bugs to the app.

In a nutshell Bit allows developers to decide how and when they want to adopt any change, and when a change is dangerous for them, they can decide to adopt it gradually. On the other hand, MFE builders can move forward quickly without the constant fear of breaking their dependents. The result of it is a huge gain in the speed of delivery.

### Decouple Collaboration from Runtime

Often we see organizations opt to use runtime composition of frontend applications as a "do all" solution without considering the drawbacks it may have on performance, SEO and MFE composition. But we need to understand the teams requirements and needs to properly consider the tradeoffs. Defaulting to build-time composition lets teams focus and collaborate on building a coherent component model for their large scale application. This makes the discussion about runtime composition (with its different flavors) to be more pragmatic as we can decide to use it when needed.  

When runtime composition is needed, there are different methods where Bit can be used to answer some of the questions it raises. [See here.](/)

### Simple, decoupled codebase

Smaller codebases are easier to maintain as they simply have less code. When distributing a single component model across multiple teams and multiple repositories we make each repository to be as small as it can be. Moreover, as all other components are available to be dependencies it makes it even easier to ensure a single codebase contains a very focused set of components.

Bit also provides a dynamic way to scale decoupled codebases, especially in cases where a codebase grows and needed to be split to several others. Bit can "source" a component to any codebase including its complete version history. So when a codebase grows too large we can split it to several smaller codebases without loosing history and context. Developers can use this capability to quickly spin up new codebases for specific requirements and use them for different experimentations POCs.

### Standardization

Ramping up the production of MFEs requires solving many small problems many times. For example, how an MFE should be constructed, testing and code quality are some of the basic requirements each developer needs to think about when building new MFE.  
Bit helps make this process repeatable and scale-able with using **environments**. This way an organization keep different types of standards according to the specific type of MFE making the process of creating new features and APIs repeatable and quick.

## Practices and Recommendations

When building Micro Frontends with Bit, we recommend the following practices:

### Git Repositories

A Bit workspace is a monorepo for components. A teams can use a single Git repository to manage the lifecycle of many components from a single place. This can simplify the flow of managing closely-related components.  
While components share the same workspace, they each get its own build pipeline and independent versions without overwhelming your workspace with many configuration files. This has several benefits:

1. Only changed components and their dependents get a new version.
1. Components from the same workspace may be built with different tools and frameworks.
1. Focus on the implementation and less on managing configurations and dependencies.

The structure of components on the filesystem is non-opinionated, meaning you can have components nested in complex directory hierarchy or have them flatten, however it fits your use case. Moreover, you can move components around in the workspace without it affecting their functionality, allowing for better flexibility when amount of components grow and you want to reorder the workspace.

Bit makes the team's workspace dynamic and flexible to their needs, enabling teams to scale to more components without locking them down to past decisions regarding workspace structure.

```sh title="Components in workspace sorted according to functionality"
├── cart
│   ├── purchase-summary
│   └── shopping-cart
└── design
    ├── base-ui
    │   ├── button
    │   └── card
    └── theme
        ├── color-pallet
        └── theme-context
```

### Build-time Composition

To achieve build time compositions each Micro Frontend is consumable as a package. With a simple `npm install` command any developer can compose any ready-made components to their application and embed a new feature to their application. This package is then logged in the consumer's `package.json` and is used also to monitor which project is using which Micro Frontend and in what version.

```sh title="Install Micro Frontend as a dependency"
npm install @my-org.scope/my-mfe
```

### Run-time Composition

Runtime composed frontends is about using different strategies to load code that is not a part of the application when a user access a page or feature. This makes critical parts of the end-user journey within a single application to be loosely coupled.

#### SDK For Runtime Integration

We recommend building an SDK for each Micro Frontend that is meant to be integrated in runtime and manage that SDK with Bit. That SDK will handle all aspects of loading and managing the Micro Frontend during the application's runtime.  
This approach simplify and scale the process of integrating MFEs by providing programmatic APIs with types and autocomplete for consumers, provides error handling, abstract cross-application communication, and even reduce the need for complex documentation. Moreover, when an organization use multiple frameworks like React and Angular, we recommend building an SDK per framework.  

The experience of using the MFE "feels" for the developer like working with a dependency, even if the MFE is a JavaScript bundle with its own runtime which is loaded from a CDN/Server or an HTML returns from a Microservice.

// TODO diagram + example

#### Module Federation

[Module Federation](https://webpack.js.org/concepts/module-federation) is a new plugin introduced in Webpack 5. It aims to make it easier to compose applications in runtime. While composing with Module Federation requires additional configuration on the consumer's `webpack.config.js`, we still recommend [building an SDK](#sdk-for-runtime-integration) that provides types and autocomplete.

:::info

Native Webpack 5 Module Federation support is in development. [See here](https://github.com/teambit/bit/discussions/4640) for more details.

:::

#### ES6 Modules

Future of runtime frontend composition is ES Modules. This means that we can use ES modules in the browser and use them in the Node.js runtime.

#### Drawbacks

Runtime composition approach has several drawbacks:

- No de-duping of shared code and dependencies as this is a bundle feature which runs during a build pipeline.
- Complex communication between the application and composed MFEs is often moved to a message bus or eventing system that is hard to scale when the number of MFE grows.
- Application maintainers get less control over their production runtime, as skipping application-MFE integration tests my result in MFE-teams delivering potentially breaking changes or bugs directly to the consumer's runtime.
- Runtime metrics, KPIs, logs and reports for applications with runtime MFEs are harder to achieve, as they are distributed between it and the various MFEs composed.

There are cases where its reasonable to utilize this approach. This can be useful as a deployment strategy where we know APIs will not change often or for integrating with legacy systems.


## Multiple Frameworks

- possible
  - buildtime
  - runtime
- do it only if really needed
- how

## Data Fetching

- api gateway
- BFF pattern

## Modeling data entities

- more than shared types
- mock data

## Updates

- npm i
- build
- ripple ci



## Feature Ownership

- hi

## Styling and Theming

- encapsulation

## Testing

Each component is testing itself and its dependencies.

## Applications D& Deployment

- apps are just very concrete components

## Summary

- yup

### Decouple application runtime from collaboration model

- make the right decisions

### The Microservice Analogy

While sharing a similar name and benefiting from splitting system engineering and teams according to business capabilities, Microservices and Micro Frontends architectures are very different.  
Micro Frontends still run by the browser as a monolithic application with a shared runtime while Microservices are deployed to different servers and communicate over the network.

Modern web frameworks already solve the problem of building modular applications from independent and decoupled services to scale frontend development (React/Vue component, Angular modules). The pragmatic approach for scaling delivery of large scale applications is adopting their approach but finding a way to distributed the development of an application across teams and repositories. This requires a different set of tools and thinking than scaling backend development.

### Not just for frontend

?
