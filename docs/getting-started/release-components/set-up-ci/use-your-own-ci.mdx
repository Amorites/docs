---
id: use-your-own-ci
title: Use Your Own CI
---

## Overview

Learn how to version and export components on CI using GitHub Actions or Gitlab CI.

## Version and Export Components on CI

### Install and configure Bit

Follow the instructions in [bit docker readme](https://github.com/teambit/bit/blob/master/scripts/docker-teambit-bit) to get a docker with bit installed.

To configure bit on the server, you need to run the following commands:

```shell
bit config set user.token ${BIT_TOKEN}
```

### Versioning and Publishing

The flow for versioning and publishing components work as follows:

1. On your local computer run `bit tag` with the `--soft` option to annotate that modified components should be versioned and exported.
1. Bit updates `.bitmap` with information on new versions to publish.
1. Collaborate with your peers on the soon-to-be published components, their semantic version and changelog messages.
1. Merge changes to main branch.
1. CI/CD versions all marked components and publish them.
1. CI/CD commits back to the repository the updated `.bitmap` without annotations on versions to be exported.

> **Where is the 'test' and 'build'?**
>
> The `tag` command runs the 'build pipeline' before versioning a component. This pipeline includes building and testing. if any of these tasks fails, the versioning process will be aborted.

:::info use soft tags in local workspaces
Components in local workspaces should be 'soft-tagged'.
That means they are registered in the `.bitmap` file as pending to be versioned, but not yet versioned.
The versioning process should only happen in the CI (once changes to the workspace are pushed to the remote repository).
This enables collaboration on components before they are tagged and exported.  
[**Learn more**](/building-with-bit/exporting-components).
:::

### Using GitHub Actions

> You can also follow along with this [example project.](https://github.com/teambit/harmony-with-github-actions)

1. Create a new [secret variable](https://docs.github.com/en/free-pro-team@latest/actions/reference/encrypted-secrets) in your Github repository. Name it `BIT_TOKEN` and set the value of it to the `user.token` value.
1. Create a new `tag-and-export.yml` file in your remote repository `./.github/workflows` directory.
1. Create your script.

Here's a demo script you can start with:

```yaml
# This workflow hard-tags and exports soft-tagged components
name: Tag and Export Components

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  tag-and-export:
    runs-on: ubuntu-latest
    if: "!contains(github.event.head_commit.message, '--skip-ci')"
    env:
      BIT_TOKEN: ${{ secrets.BIT_TOKEN }}

    steps:
      - uses: actions/checkout@v2
      - name: Use Node.js 12
        uses: actions/setup-node@v1
        with:
          node-version: 12.x
      - name: Install Bit Version Manager
        run: npm i -g @teambit/bvm
      - name: Install latest Bit version
        run: bvm install
      - name: add bvm bin folder to path
        run: echo "$HOME/bin" >> $GITHUB_PATH
      - name: Set up bit config
        run: |
          bit config set analytics_reporting false
          bit config set anonymous_reporting false
          bit config set user.token $BIT_TOKEN
      - name: Install packages using bit
        run: bit install
      - name: Hard-tag pending components
        run: bit tag --persist
      - name: Export components
        run: bit export
      - name: Commit changes made to .bitmap
        run: |
          git config --global user.name '${{ github.actor }}'
          git config --global user.email '${{ github.actor }}@users.noreply.github.com'
          git add .bitmap
          git commit -m "update .bitmap with new component versions (automated). --skip-ci"
          git push
```

### Using GitLab CI

1. Generate a Personal Access Token with "Read Repository" and "Write Repository" permissions (this will be `GL_TOKEN`).
1. Generate `BIT_TOKEN` by grabbing it from your local "bit config" output.
1. Configure both tokens as project variables for your GitLab project and name them `GL_TOKEN` and `BIT_USER_TOKEN`.
1. Create a `.gitlab-ci.yml` file in the root of the repository.
1. Create your script.

Here's a demo script you can start with:

```yml
publish_components:
  image: node:latest
  only: master
  script:
    # Install Bit and configure permissions
    - npm i -g @teambit/bvm
    - bvm install
    - export PATH=$HOME/bin:$PATH
    - bit config set analytics_reporting false
    - bit config set anonymous_reporting false
    - bit config set user.token $BIT_TOKEN
    # Install dependencies
    - bit install
    # Version all pending components
    - bit tag --persist
    # Export components
    - bit export
    # Setup Git and commit back .bitmap changes
    - git config --global user.email "some@email.address"
    - git config --global user.name "some ci account"
    - export GL_RELEASE_GITLAB_API_TOKEN=$GL_TOKEN
    # This checkout is a workaround for the "error: src refspec master does not match any." error
    - git checkout master
    # Add the modified ".bitmap" file
    - git add .
    # Replace origin with authenticated origin
    - git remote rm origin
    - git remote add origin https://[repo-owner]:$GL_RELEASE_GITLAB_API_TOKEN@gitlab.com/[repo-ower]/[repo-name].git
    # Using [skip ci] as its a feature for GitLab that will not trigger CI for this commit
    - git commit -am 'publish components [skip ci]'
    - git pull origin master
    - git push origin master
```
